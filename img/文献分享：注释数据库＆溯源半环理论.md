@[toc]

[原文](https://doi.org/10.1145/1265530.1265535)

# $\textbf{1. }$核心动机与基础工具

> ## $\textbf{1.1. }$注释关系: 对关系的扩展
>
> > ### $\textbf{1.1.1. }$概念与示例
> >
> > > :one:注释$\text{(annotated)}$关系：对关系的扩展
> > >
> > > 1. 含义：关系数据库中的某个关系的每行中，都额外配备了一个注释
> > > 2. 类型：即注释的类型
> > >    |    注释类型     | 注释的功能                                                   | 处理的数据库             |
> > >    | :-------------: | :----------------------------------------------------------- | :----------------------- |
> > >    |    布尔变量     | 指示某一行数据是否存真的存在于数据库中                       | 不完整数据库             |
> > >    |     概率值      | 指示某一行数据以多大的概率存在于数据库中                     | 概率数据库               |
> > >    |     整数值      | 指示某一行数据在数据库中重复出现了多少次                     | 重复数据库$\text{(Bag)}$ |
> > >    | $\text{ID}$集合 | 指示$\text{Join}$等操作后的表格的某一行来自操作前表格的哪些行 | 需溯源的系统             |
> > > 3. 查询：区别于传统关系数据库，不仅要计算出数据本身，还要依据注释的规则计算出其附带的注释
> > > 4. 语义：在本文中表示，一套用于计算输出元组注释值的数学规则，比如包的语义就是自然数加乘
> > >
> > > :two:简单示例：可能表$\text{(Maybe-Table)}$及其查询，当注释为$?$
> > >
> > > 1. 含义：可能表与可能世界
> > >    - 可能表：在某关系中，若某些行不确定其是否存在于该关系中，则直接给其注释一个$?$标记、
> > >      $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&?\\\hline{}d&b&e&?\\\hline{}f&g&e&?\\\hline\end{array}$ 
> > >    - 可能世界：可能表中所有可能的情况所构成的集合，有$n$个$?$就蕴含了$2^n$个确定的关系数据库
> > > 2. 查询：以$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$为例
> > >    - 查询：生成可能表的可能世界中所有的确定表，然后在所有的确定表中执行查询(结果如下)
> > >      ${q(R)}=
> > >      \left\{
> > >      \varnothing,
> > >      \boxed{ac},
> > >      \boxed{de},
> > >      \boxed{fe},
> > >      \boxed{\begin{array}{c}ac\\ae\\dc\\de\end{array}},
> > >      \boxed{\begin{array}{c}de\\fe\end{array}},
> > >      \boxed{\begin{array}{c}ac\\fe\end{array}},
> > >      \boxed{\begin{array}{c}ac\\ae\\dc\\de\\fe\end{array}}
> > >      \right\}$
> > >    - 局限：查询结果的元组间存在依赖关系(例如有$ae$必有$dc$)，而可能表无法表征这种依赖关系
> >
> > ### $\textbf{1.1.2. }$三种高度相似的注释关系
> >
> > > :one:$\text{c-}$表及其查询：当注释为布尔变量，用以解决可能的局限
> > >
> > > 1. 结构：不再使用模糊的$?$，而是给每个不确定的元组分配了一个布尔变量作为注释
> > >    $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&\text{Bool}_1\\\hline{}d&b&e&\text{Bool}_2\\\hline{}f&g&e&\text{Bool}_3\\\hline\end{array}$
> > >    - 可能世界中所有的情况，由此就与$\text{Bool}_1\text{Bool}_2\text{Bool}_3$的真假赋值一一对应
> > > 2. 查询：注释的计算规则需满足所谓扩展的关系代数
> > >    - 规则：扩展关系代数
> > >      |   运算    |             规则             | 示例                                                         |
> > >      | :-------: | :--------------------------: | :----------------------------------------------------------- |
> > >      |   $\pi$   |   单表$\pi$时其注释$\lor$    | ${\pi}\left(\,\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1\\\hline{}a&\text{Bool}_2\\\hline\end{array}\,\right){=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1{\lor}\text{Bool}_2\\\hline\end{array}$ |
> > >      | $\bowtie$ | 两表$\bowtie$时其注释$\land$ | $\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1\\\hline\end{array}{\,\bowtie\,}\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1{\land}\text{Bool}_2\\\hline\end{array}$ |
> > >      |  $\cup$   |   两表$\cup$时其注释$\lor$   | $\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1\\\hline\end{array}{\,\cup\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Bool}_1{\lor}\text{Bool}_2\\\hline\end{array}$ |
> > >    - 示例：$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$
> > >      $\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >      \hline\hline{}a&c&\left(\text{Bool}_1{\land}\text{Bool}_1\right){\lor}\left(\text{Bool}_1{\land}\text{Bool}_1\right)\\
> > >      \hline{}a&e&\text{Bool}_1{\land}\text{Bool}_2\\
> > >      \hline{}d&c&\text{Bool}_1{\land}\text{Bool}_2\\
> > >      \hline{}d&e&\left(\text{Bool}_2{\land}\text{Bool}_2\right){\lor}\left(\text{Bool}_2{\land}\text{Bool}_2\right){\lor}\left(\text{Bool}_2{\land}\text{Bool}_3\right)\\
> > >      \hline{}f&e&\left(\text{Bool}_3{\land}\text{Bool}_3\right){\lor}\left(\text{Bool}_3{\land}\text{Bool}_3\right){\lor}\left(\text{Bool}_2{\land}\text{Bool}_3\right)\\
> > >      \hline
> > >      \end{array}{\,=\,}\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >      \hline\hline{}a&c&\text{Bool}_1\\
> > >      \hline{}a&e&\text{Bool}_1{\land}\text{Bool}_2\\
> > >      \hline{}d&c&\text{Bool}_1{\land}\text{Bool}_2\\
> > >      \hline{}d&e&\text{Bool}_2\\
> > >      \hline{}f&e&\text{Bool}_3\\
> > >      \hline
> > >      \end{array}$
> > >
> > > :two:包$\text{(Bag)}$及其查询：当注释为该行元素出现次数
> > >
> > > 1. 结构：包中的元素可多次出现，并用注释标记其在表中出现次数(如第一行出现$\text{Const}_1$次)
> > >    $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&\text{Const}_1\\\hline{}d&b&e&\text{Const}_2\\\hline{}f&g&e&\text{Const}_3\\\hline\end{array}$
> > > 2. 查询：注释的计算规则需满足所谓扩展的关系代数
> > >    - 规则：扩展关系代数，与$\text{c-}$表的规则在算数逻辑上完全对应
> > >      |   运算    |           规则            | 示例                                                         |
> > >      | :-------: | :-----------------------: | :----------------------------------------------------------- |
> > >      |   $\pi$   |     单表$\pi$时${+}$      | ${\pi}\left(\,\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1\\\hline{}a&\text{Const}_2\\\hline\end{array}\,\right){=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1{{+}}\text{Const}_2\\\hline\end{array}$ |
> > >      | $\bowtie$ | 两表$\bowtie$时${\times}$ | $\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1\\\hline\end{array}{\,\bowtie\,}\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1{{\times}}\text{Const}_2\\\hline\end{array}$ |
> > >      |  $\cup$   |     两表$\cup$时${+}$     | $\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1\\\hline\end{array}{\,\cup\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Const}_1{{+}}\text{Const}_2\\\hline\end{array}$ |
> > >    - 示例：$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$
> > >      $\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >      \hline\hline{}a&c&\left(\text{Const}_1{{\times}}\text{Const}_1\right){{+}}\left(\text{Const}_1{{\times}}\text{Const}_1\right)\\
> > >      \hline{}a&e&\text{Const}_1{{\times}}\text{Const}_2\\
> > >      \hline{}d&c&\text{Const}_1{{\times}}\text{Const}_2\\
> > >      \hline{}d&e&\left(\text{Const}_2{{\times}}\text{Const}_2\right){{+}}\left(\text{Const}_2{{\times}}\text{Const}_2\right){{+}}\left(\text{Const}_2{{\times}}\text{Const}_3\right)\\
> > >      \hline{}f&e&\left(\text{Const}_3{{\times}}\text{Const}_3\right){{+}}\left(\text{Const}_3{{\times}}\text{Const}_3\right){{+}}\left(\text{Const}_2{{\times}}\text{Const}_3\right)\\
> > >      \hline
> > >      \end{array}$ 
> > >
> > > :three:概率表及其查询：当注释为该行元素出现的概率
> > >
> > > 1. 结构：每条记录的存在与否都伴随着一个概率值，例如第一行出现在该关系中的概率为$\text{Event}_1$
> > >    $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&\text{Prob}_1\\\hline{}d&b&e&\text{Prob}_2\\\hline{}f&g&e&\text{Prob}_3\\\hline\end{array}$
> > > 2. 查询：注释的计算规则需满足所谓扩展的关系代数
> > >    - 预处理：由于概率值无法直接体现依赖关系，故不直接对概率值运算，而是先抽象成事件
> > >      $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&\text{Event}_1\\\hline{}d&b&e&\text{Event}_2\\\hline{}f&g&e&\text{Event}_3\\\hline\end{array}$
> > >    - 规则：扩展关系代数，与$\text{c-}$表规则的逻辑上，以及包规则的代数上完全对应
> > >      |   运算    |          规则           | 示例                                                         |
> > >      | :-------: | :---------------------: | :----------------------------------------------------------- |
> > >      |   $\pi$   |   单表$\pi$时${\cup}$   | ${\pi}\left(\,\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1\\\hline{}a&\text{Event}_2\\\hline\end{array}\,\right){=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1{{\cup}}\text{Event}_2\\\hline\end{array}$ |
> > >      | $\bowtie$ | 两表$\bowtie$时${\cap}$ | $\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1\\\hline\end{array}{\,\bowtie\,}\begin{array}{|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1{{\cap}}\text{Event}_2\\\hline\end{array}$ |
> > >      |  $\cup$   |  两表$\cup$时${\cup}$   | $\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1\\\hline\end{array}{\,\cup\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_2\\\hline\end{array}{\,=\,}\begin{array}{|c|c|}\hline\textbf{A}&\textbf{Ann.}\\\hline\hline{}a&\text{Event}_1{{\cup}}\text{Event}_2\\\hline\end{array}$ |
> > >    - 示例：$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$，<font color=red>最后将事件转化为事件的概率</font>
> > >      $\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >      \hline\hline{}a&c&\Pr[\left(\text{Event}_1{{\cap}}\text{Event}_1\right){{\cup}}\left(\text{Event}_1{{\cap}}\text{Event}_1\right)]\\
> > >      \hline{}a&e&\Pr[\text{Event}_1{{\cap}}\text{Event}_2]\\
> > >      \hline{}d&c&\Pr[\text{Event}_1{{\cap}}\text{Event}_2]\\
> > >      \hline{}d&e&\Pr[\left(\text{Event}_2{{\cap}}\text{Event}_2\right){{\cup}}\left(\text{Event}_2{{\cap}}\text{Event}_2\right){{\cup}}\left(\text{Event}_2{{\cap}}\text{Event}_3\right)]\\
> > >      \hline{}f&e&\Pr[\left(\text{Event}_3{{\cap}}\text{Event}_3\right){{\cup}}\left(\text{Event}_3{{\cap}}\text{Event}_3\right){{\cup}}\left(\text{Event}_2{{\cap}}\text{Event}_3\right)]\\
> > >      \hline
> > >      \end{array}$ 
>
> ## $\textbf{1.2. }$交换半环: 对几种注释关系的统一描述
>
> > :one:交换半环概念：一个代数结构$(K,{\oplus},{\otimes},0,1)$，对$a,b,c{\in}K$满足
> >
> > 1. 加乘规律：下表中的，再加上一个零元$a{\otimes}0{=}0$
> >    |          |                       结合律                        |           交换律            |      单位元       |
> >    | :------: | :-------------------------------------------------: | :-------------------------: | :---------------: |
> >    | 加法规则 |   $(a{\oplus}b){\oplus}c{=}a{\oplus}(b{\oplus}c)$   |  $a{\oplus}b{=}b{\oplus}a$  | $a{\oplus}0{=}a$  |
> >    | 乘法规则 | $(a{\otimes}b){\otimes}c{=}a{\otimes}(b{\otimes}c)$ | $a{\otimes}b{=}b{\otimes}a$ | $a{\otimes}1{=}a$ |
> > 2. 桥梁规则：分配律$a{\otimes}(b{\oplus}c){=}(a{\otimes}b){\oplus}(a{\otimes}c)$
> >
> > :two:交换半环与注释关系
> >
> > 1. 等价关系：对几种注释关系的描述
> >    |     场景      | $\boldsymbol{K}$(标注集)        | $\boldsymbol{\oplus}$(并/投影) | $\boldsymbol{\otimes}$(连接/选择) | $\boldsymbol{0}$(不存在) | $\boldsymbol{1}$(真/单位) |
> >    | :-----------: | :------------------------------ | :----------------------------- | :-------------------------------- | :----------------------- | :------------------------ |
> >    |     集合      | $B{=}\{\text{false,true}\}$     | ${\lor}$(逻辑或)               | ${\land}$(逻辑与)                 | $\text{false}$           | $\text{true}$             |
> >    |      包       | $\mathbb{N}{=}\{0,1,2,...\}$    | ${+}$(加法)                    | ${\times}$(乘法)                  | $0$                      | $1$                       |
> >    | $\text{c-}$表 | $\text{PosBool}(B)$(布尔公式集) | ${\lor}$(析取)                 | ${\land}$(合取)                   | $\text{false}$           | $\text{true}$             |
> >    |     概率      | $P(\Omega)$(事件集)             | ${\cup}$(事件并)               | ${\cap}$(事件交)                  | $\varnothing$(空事件)    | $\Omega$(全事件)          |
> > 2. 关于幂等性：即$a{\oplus}a{=}a$，集合$/\text{c-}$表$/$概率表都满足此性质，但包不满足故不考虑此性质
> >
> > :three:不同半环结构的同态
> >
> > 1. 同态概念：
> >    - 含义：在不同的半环结构间，对标注进行翻译
> >    - 定义：考虑交换半环$(K_x,{\oplus}_x,\otimes_x,0_x,1_x)$和$(K_y,{\oplus}_y,\otimes_y,0_y,1_y)$，同态函数为$h{:}K_x{\to}K_y$ 
> >    - 示例：包$(\mathbb{N},{+},{\times},0,1)$转$\text{c-}$表$(\text{PosBool}(B),{\lor},{\land},\text{false},\text{true})$，$\begin{cases}h(n){=}\text{true}(n{>}0)\\h(n){=}\text{false}(n{=}0)\end{cases}(n{\in}\mathbb{N})$ 
> > 2. 半环同态：
> >    - 概念：当$h$同态函数满足以下性质时，该同态叫做半环同态
> >      |                    规则                    | 解释                   |
> >      | :----------------------------------------: | :--------------------- |
> >      | $h(a{{\oplus}_x}b){=}h(a){{\oplus}_y}h(b)$ | 翻译“和”等于“翻译”的和 |
> >      |  $h(a{\otimes_x}b){=}h(a){\otimes_y}h(b)$  | 翻译“积”等于“翻译”的积 |
> >      |               $h(0_x){=}0_y$               | 将此$0$翻译成彼$0$     |
> >      |               $h(1_x){=}1_y$               | 将此$1$翻译成彼$1$     |
> >    - 性质：先翻译再查询$=$先查询再翻译即$q(h(R)){=}h(R(q))$，当且仅当$h$为半环同态时成立

# $\textbf{2. }$非递归查询的溯源

> ## $\textbf{2.1. }\boldsymbol{K}\textbf{-}$关系及其$\boldsymbol{{\mathcal{{RA}}}^{\textbf{+}}}$(正关系代数)运算
>
> > :one:关系的重定义
> >
> > 1. 元组$\text{(Tuple)}$重定义
> >    - 定义：$t{:\,}$属性集$U{\to}$值域$\mathbb{D}$，每个属性构成的集合被视作定义域，每个属性的值的集合被视作值域
> >    - 示例：考虑关系$\begin{array}{|c|c|c|}\hline\text{\textbf{A}}&\text{\textbf{B}}&\text{\textbf{C}}\\\hline{}a&b&c\\\hline{}d&b&f\\\hline\end{array}$，其中第一行$\begin{cases}t_1(A){=}a\\t_1(B){=}b\\t_1(C){=}c\end{cases}$，第二行$\begin{cases}t_2(A){=}d\\t_2(B){=}b\\t_2(C){=}f\end{cases}$
> >    - 特征：每行被视为一个函数，使得元组的表征完全不依赖于关系中属性的顺序
> > 2. 关系$\text{(Relation)}$重定义
> >    - 元组集：对于一个属性集合，其中属性理论上所有可能的取值情况的集合，记作$U\text{-}Tup$
> >    - 关系：元组集的子集，如对于$U\text{-}Tup{=}\{t_1,t_2,t_3...\}$，关系$\begin{array}{|c|c|c|}\hline\text{\textbf{A}}&\text{\textbf{B}}&\text{\textbf{C}}\\\hline{}a&b&c\\\hline{}d&b&f\\\hline\end{array}$可表示为$R{=}\{t_1,t_2\}$ 
> >
> > :two:$K\text{-}$关系的概念
> >
> > 1. $K\text{-}$值：注释关系中注释的值域，如注释为布尔值时$K{=}\{0,1\}$，但必须有$0{\in}K$表示该元组不存在
> > 2. $K\text{-}$关系：将关系定义为函数$R{:\,}U\text{-}Tup{\to}K$，让每个可能的元组$t{\in}U\text{-}Tup$都赋予一个注释值$K$
> >    |              情形              | $\boldsymbol{K}$值                                           |
> >    | :----------------------------: | :----------------------------------------------------------- |
> >    | $t{\in}U\text{-}Tup$在该关系中 | 按照一定的规则赋予其$K$注释值，如出现概率$/$重复次数$/$布尔$1$等 |
> >    | $t{\in}U\text{-}Tup$在该关系外 | 统一设定其注释值$K{=}0$                                      |
> > 3. 支持集：即$K\text{-}$关系中那些标注不为$0$的元组的集合，也就是传统意义上关系数据库中的那个关系
> >
> > :three:$K\text{-}$关系的${{\mathcal{{RA}}}^{\textbf{+}}}$运算
> >
> > 1. $K\text{-}$关系上的代数运算
> >    |  运算  | 定义                                              | 解释                                                         |
> >    | :----: | :------------------------------------------------ | :----------------------------------------------------------- |
> >    | 空关系 | $\varnothing(t){=}0$                              | 空关系中没有任何元组，即所有$K$都为$0$                       |
> >    |  并集  | $(R_1{\cup}R_2)(t){=}R_1(t){+}R_2(t)$             | $t$在合并后关系中的注释，直接为合并的二者相加                |
> >    |  投影  | $(\pi_VR)(t){=}\sum{R}(t^\prime)$                 | 投影后若多行$t^\prime$合并为一行$t$，$t$注释为所有$t^{\prime}$相加 |
> >    |  选择  | $(\sigma_PR)(t){=}R(t){\times}P(t)$               | 条件$P$给$t$设定一个$P(t){\in}\{0,1\}$，筛选$/$留下这行      |
> >    |  连接  | $(R_1{\bowtie}R_2)(t){=}R_1(t_1){\times}R_2(t_2)$ | 由$t_1/t_2$(自然)连接的新元组$t$的注释值为前二者乘积         |
> >    | 重命名 | $(\rho_\beta{R})(t){=}R(t{\circ}\beta)$           | 仅改变注释的属性名，$\beta$为改名规则$/\circ$为函数复合      |
> > 2. 补充：在一个有限$K\text{-}$关系上执行以上运算，结果必然有也是一个有限$K\text{-}$关系，即计算具有封闭性
> >
> > :four:$K\text{-}$关系与半环：<mark>$K\text{-}$关系代数只能用交换半环来描述</mark>
>
> ## $\textbf{2.2. }$ 溯源的多项式表示
>
> > ### $\textbf{2.2.1. }$传统溯源
> >
> > > :one:溯源概念：
> > >
> > > 1. 含义：关系的一种注释，为查询结果计算一个贡献元组$\text{ID}$集，用来指示结果有哪些元组贡献而来
> > > 2. 示例：$\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&\{p1,q1\}\\\hline{}a&b&e&\{p1,q2\}\\\hline{}d&b&c&\{p2,q1\}\\\hline{}d&b&e&\{p2,q2\}\\\hline{}f&g&e&\{p3,q3\}\\\hline\end{array}{\,=\,}\begin{array}{|c|c|c|}\hline
> > >    \textbf{A}&\textbf{B}&\textbf{Anno.}\\\hline\hline
> > >    a&b&\{p1\}\\\hline
> > >    d&b&\{p2\}\\\hline
> > >    f&g&\{p3\}\\\hline
> > >    \end{array}
> > >    {\,\bowtie\,}
> > >    \begin{array}{|c|c|c|}\hline
> > >    \textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline
> > >    b&c&\{q1\}\\\hline
> > >    b&e&\{q2\}\\\hline
> > >    g&e&\{q3\}\\\hline
> > >    \end{array}$ 
> > >
> > > :two:溯源半环：
> > >
> > > 1. 结构：溯源完全可以被半环$(K,\oplus,\otimes,0,1){=}\left({\mathcal{P}\left(X\right),\cup,\cup,\varnothing,\varnothing}\right)$描述，但其表现力较弱
> > >    |               结构                | 解释                                                         |
> > >    | :-------------------------------: | :----------------------------------------------------------- |
> > >    |                $X$                | 所有元组$\text{ID}$构成的集合，如$\{p,r,s\}$                 |
> > >    | $K{\to}\mathcal{P}\left(X\right)$ | 即$X$的幂集，是$X$所有可能的子集的集合，如$\{p,r\}{\in}\mathcal{P}\left(X\right){=}\{p,r,s\}$ |
> > >    |       ${\oplus}{\to}{\cup}$       | 通过`UNION/PROJECT`导致多个来源共同产生同一元组，对来源的溯源进行合并 |
> > >    |      ${\otimes}{\to}{\cup}$       | 通过`JOIN`操作导致不同元组合并时，对其溯源进行合并           |
> > >    |       $0{\to}{\varnothing}$       | 即${\varnothing}$是加法的单位元，满足$a{\cup}{\varnothing}{=}a$ |
> > >    |       $1{\to}{\varnothing}$       | 即${\varnothing}$是乘法的单位元，满足$a{\cup}{\varnothing}{=}a$ |
> > > 2. 局限性：同样以$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$为例
> > >    $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&p\\\hline{}d&b&e&r\\\hline{}f&g&e&s\\\hline\end{array}{\,\to\,}q\left(R\right){\,=\,}\begin{array}{|c|c|c|}
> > >    \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >    \hline\hline{}a&c&\{p\}\\
> > >    \hline{}a&e&\{p,r\}\\
> > >    \hline{}d&c&\{p,r\}\\
> > >    \hline{}d&e&\{r,s\}\\
> > >    \hline{}f&e&\{r,s\}\\
> > >    \hline
> > >    \end{array}$
> > >    - 局限：只能指示结果中元组的来源，而"抹去"了如何从这些来源派生出结果元组
> > >    - 影响：如元组$r$可读度高$/s$可信度低，而$(d,e)/(f,e)$的溯源都是$\{r,s\}$(尽管二者可信度不同)
> > >    - 解决：用多项式而非集合，表征由哪些来源得到元组$+$这些来源如何构成元组，即溯源多项式
> >
> > ### $\textbf{2.2.2. }$溯源多项式半环
> >
> > > :one:基本概念
> > >
> > > 1. 结构：$(K,\oplus,\otimes,0,1){=}(\mathbb{N}[X],+,\times,0,1)$ 
> > >    |      结构       | 解释                                                         |
> > >    | :-------------: | :----------------------------------------------------------- |
> > >    |       $X$       | 多项式变量，代表输入元组的$\text{ID}$比如$r/p/s$等           |
> > >    |  $\mathbb{N}$   | 所想是的系数，为$\mathbb{N}{=}\{0,1,2,....\}$                |
> > >    | $\mathbb{N}[X]$ | 即注释集，多项式变量$+$系数$\to$所能构成的所有多项式的集合，如$2s^2{+}rs{\in}\mathbb{N}[X]$ |
> > >    |      ${+}$      | 通过`UNION/PROJECT`导致多个来源共同产生同一元组，对溯源多项式相加 |
> > >    |   ${\times}$    | 通过`JOIN`操作导致不同元组合并时，对其溯源多项式相乘         |
> > >    |       $0$       | 加法单位元，就是单纯的数字$0$，满足某多项式$+0{=}$某多项式   |
> > >    |       $1$       | 乘法单位元，就是单纯的数字$1$，满足某多项式${\times}1{=}$某多项式 |
> > > 2. 示例：还是$q\left(R\right){\overset{\text{def}}{=}}{\pi}_{\mathrm{{AC}}}\left({{\pi}_{\mathrm{{AB}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R{\cup}{\pi}_{\mathrm{{AC}}}R{\bowtie}{\pi}_{\mathrm{{BC}}}R}\right)$为例
> > >    $R{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.}\\\hline\hline{}a&b&c&p\\\hline{}d&b&e&r\\\hline{}f&g&e&s\\\hline\end{array}{\,\to\,}q\left(R\right){\,=\,}\begin{array}{|c|c|c|}
> > >    \hline\textbf{A}&\textbf{C}&\textbf{Anno.}\\
> > >    \hline\hline{}a&c&2p^2\\
> > >    \hline{}a&e&pr\\
> > >    \hline{}d&c&pr\\
> > >    \hline{}d&e&2r^2{+}rs\\
> > >    \hline{}f&e&2s^2{+}rs\\
> > >    \hline
> > >    \end{array}$ 
> > >
> > > :two:溯源多项式半环$\mathbb{N}[X]$的普适性
> > >
> > > 1. 核心思想：$\mathbb{N}[X]$是所有交换半环的模板，可被同态函数${h}_{v}$按规则$v$翻译成任何半环
> > >    |   结构    | 含义                                                         |
> > >    | :-------: | :----------------------------------------------------------- |
> > >    | ${h}_{v}$ | 本质是一个半环同态(函数)，接收一个溯源多项式，按照规则$v$算出其在目标半环中的值 |
> > >    |    $v$    | 本质是一套规则，指示了每个元组$\text{ID}$(如$p/r/s$)在目标半环中被视作什么 |
> > >    - 示例：从溯源多项式半环转换为包语义的半环
> > >      - 操作：若每个$r/p/s$有计数$v(p){=}v(r){=}v(s){=}1$，则$v(2s^2{+}rs){=}2v(s)v(s){+}v(r)v(s){=}3$
> > >      - 解释：由$2s^2{+}rs$知，构成元组$(f,e)$有三途径，故结果中有三组$(f,e)$即包的注释值为$3$
> > >    - 补充：这里所说的任何半环，是<mark>任意的所有半环</mark>，而不仅限于文中所提到的几个半环
> > > 2. 核心性质：因子分解定理$q(R){=}{h}_{v}{\circ}q(\bar{R})$ 
> > >    - 含义：如下表两条路径(及所得到的结果)完全等价
> > >      |            路径            | 解释                                                         |
> > >      | :------------------------: | :----------------------------------------------------------- |
> > >      |           $q(R)$           | 直接在半环$(K,\oplus,\otimes,0,1)$上对关系$R$执行计算(查询)  |
> > >      | ${h}_{v}{\circ}q(\bar{R})$ | 1. 将$R$抽象为溯源多项式关系$\bar{R}$<br>2. 在溯源半环$(\mathbb{N}[X],+,\times,0,1)$上执行计算得到$q(\bar{R})$<br>3. 将计算结果转化回半环$(K,\oplus,\otimes,0,1)$，即${h}_{v}{\circ}q(\bar{R})$ |
> > >    - 示例：$R{\xrightarrow{\text{ID}替代数目}}\bar{R}$，计算查询的溯源多项式，按计数$v(p){=}2/v(r){=}5/v(s){=}1$多项式求值
> > >      $\begin{cases}
> > >      \bar{R}{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.(ID) }\\\hline\hline{}a&b&c&p\\\hline{}d&b&e&r\\\hline{}f&g&e&s\\\hline\end{array}{\,\to\,}q(\bar{R}){\,=\,}\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.(ID) }\\
> > >      \hline\hline{}a&c&2p^2\\
> > >      \hline{}a&e&pr\\
> > >      \hline{}d&c&pr\\
> > >      \hline{}d&e&2r^2{+}rs\\
> > >      \hline{}f&e&2s^2{+}rs\\
> > >      \hline
> > >      \end{array}\\\\
> > >      {R}{\,=\,}\begin{array}{|c|c|c|c|}\hline\textbf{A}&\textbf{B}&\textbf{C}&\textbf{Anno.(数目)}\\\hline\hline{}a&b&c&2\\\hline{}d&b&e&5\\\hline{}f&g&e&1\\\hline\end{array}{\,\to\,}q({R}){\,=\,}\begin{array}{|c|c|l|}
> > >      \hline\textbf{A}&\textbf{C}&\textbf{Anno.(数目)}\\
> > >      \hline\hline{}a&c&2v(p)^2{=}8\\
> > >      \hline{}a&e&v(p)v(r){=}10\\
> > >      \hline{}d&c&v(p)v(r){=}10\\
> > >      \hline{}d&e&2v(r)^2{+}v(r)v(s){=}55\\
> > >      \hline{}f&e&2v(s)^2{+}v(r)v(s){=}7\\
> > >      \hline
> > >      \end{array}
> > >      \end{cases}$
> > >    - 意义：可将查询的逻辑执行与具体的溯源语义分离，只计算一次但用不同${h}_{v}$得到多种结果

# $\textbf{3. }$处理递归查询: 基于$\textbf{Datalog}$

> ## $\textbf{3.1. }$关于$\textbf{Datalog}$
>
> > ### $\textbf{3.1.1. }$$\textbf{Datalog}$基本结构
> >
> > > :one:事实$\text{(Fact)}$
> > >
> > > 1. 事实：数据库中现存的数据(即具体的一行元组），写作`关系名('常量1', '常量2', ...)`
> > >    - 推导事实：即不存在于数据库当中，但是可以从现有事实按照规则推导出来
> > > 2. 补充：存放事实的数据库叫外延数据库，存放推导事实的叫内涵数据库
> > >
> > > :two:规则$\text{(Rule)}$
> > >
> > > 1. 含义：从事实(现存于数据库中的$/$从已知事实推导而来的)中，推导出新事实的逻辑
> > > 2. 结构：`Head:-Body`或`Head:-atom1,atom2,...`
> > >    - `Head`是想要输出的结果，如`EmpDept(Name, DeptName)`
> > >    - `atom`是查询条件，相邻`atom`有相同变量可实现`join`，如`E(Eid,Name,Did),D(Did,Dpt)`
> > >
> > > :three:谓词$\text{(Predicates)}$
> > >
> > > 1. 含义：就是关系名，如`EmpDept(Name, DeptName)`中的`EmpDept` 
> > > 2. 种类：按照是否作为数据库中的数据源
> > >    - $\text{EDB}$谓词：从不出现在任何规则的`head`部分的谓词，充当纯粹的数据源
> > >    - $\text{IDB}$谓词：至少在一条规则的`head`部分出现过，代表了被推导而出的规则
> >
> > ### $\textbf{3.1.2. }\textbf{Datalog}$的两种查询
> >
> > > :one:非递归：合取查询$\text{(ConjunctiveQuery)}$
> > >
> > > 1. 自然连接：若$A$表中有$n$列分别和$B$表中的$n$列同名，则当两表中这$n$列都相同时才进行连接
> > >    $\begin{array}{|c|c|c|}\hline\text{\textbf{Eid}}&\text{\textbf{Name}}&\text{\textbf{Did}}\\\hline1&\text{张三}&101\\2&\text{李四}&102\\3&\text{王五}&104\\\hline\end{array}{\,\bowtie\,}\begin{array}{|c|c|}\hline\text{\textbf{Did}}&\text{\textbf{Dpt}}\\\hline101&\text{市场部}\\102&\text{技术部}\\\hline\end{array}{\,\to\,}\begin{array}{|c|c|c|c|}\hline\text{\textbf{Did}}&\text{\textbf{Eid}}&\text{\textbf{Name}}&\text{\textbf{Dpt}}\\\hline101&1&\text{张三}&\text{市场部}\\102&2&\text{李四}&\text{技术部}\\\hline\end{array}$
> > > 2. 合取查询结构：`Head:-Body`或`Head:-atom1,atom2,...`即同时满足若干原子条件时，输出结果
> > > 3. 合取查询示例：合取查询除了囊括了自然连接，还可以隐式地进行选择和投影
> > >    |         操作         | 合取查询                                                  |
> > >    | :------------------: | :-------------------------------------------------------- |
> > >    |      同自然连接      | `R(Eid,Name,Did,Dpt):-E(Eid,Name,Did),D(Did,Dpt)`         |
> > >    |      对结果投影      | `R(Name):-E(Eid,Name,Did),D(Did,Dpt)`                     |
> > >    |      对原子选择      | `R(Eid,Name,Did,Dpt):-E(Eid,Name,Did),D(Did,Dpt),Did>100` |
> > >    | 更复杂($\theta$)连接 | `R(Eid,Name,Did,Dpt):-E(Eid,Name,Did),D(Did,Dpt),Eid<Did` |
> > >    - 对于`head`只能进行投影操作，而对`body`中的每个`atom`只能进行选择操作(当然还包括连接)
> > >    - 对结果不进行任何投影的叫完全合取查询，对结果投影去除某些列的即为非完全合取查询
> > >
> > > :two:递归查询：对合取查询的深化
> > >
> > > 1. 基本思想：允许头部定义的谓词再次出现在规则的体部，示例如下‘
> > >    ```txt
> > >    Anc(x,y):-Dad(x,y).
> > >    %一个合取查询,如果x是y的父母，那么x就是y的祖先
> > >       
> > >    Anc(x,y):-Dad(x,z),Anc(z,y).
> > >    %开始递归,body部分出现了head中定义的谓词，即如果x是z父母及z是y祖先，则x也是y祖先  
> > >    ```
> > > 2. 递归计算：迭代与不动点，以免陷入死循环
> > >    | 轮次 |     输入     | 操作(应用什么规则)                  | `Anc`表                   |
> > >    | :--: | :----------: | ----------------------------------- | :------------------------ |
> > >    | $0$  | $\text{N/A}$ | $\text{N/A}$                        | `Anc-0`(空)               |
> > >    | $1$  |   `Anc-0`    | 基础`Anc(x,y):-Dad(x,y)`            | `Anc-1`(新增父子关系)     |
> > >    | $2$  |   `Anc-1`    | 递归`Anc(x,y):-Dad(x,y),Anc-1(x,y)` | `Anc-2`(新增祖父子关系)   |
> > >    | $3$  |   `Anc-2`    | 递归`Anc(x,y):-Dad(x,y),Anc-2(x,y)` | `Anc-3`(新增曾祖父子关系) |
> > >      - 迭代终止：一直到`Anc`表内不再新增元素时迭代结束，此时的`Anc`表叫做不动点
> > >
> >
> > ### $\textbf{3.1.3. }\textbf{Datalog}$的两种等价语义
> >
> > > :one:证明论语义：从结论倒推证明过程
> > >
> > > 1. 推导树：根是等待被证明的结论，叶子是基础事实$\text{EDB}$，中间结构反应了按照规则推导的过程
> > >    ```txt
> > >    规则: Grandparent('A','C') :- Parent('A','B'), Parent('B','C')
> > >   
> > >    推导:  Grandparent('A','C')            <-- 结论(根)
> > >               /           \
> > >        Parent('A','B')  Parent('B','C')  <-- 证据集合(叶子)
> > >             (证据1)         (证据2)
> > >    ```
> > >    - 整体而言，一颗推导树代表了从基础事实(叶节点)，推导到最终结论(根节点)的全部过程
> > > 2. 推导：推导树中自上而下的过程
> > >    - 开始：从根节点处的给定事实$R(A_1,A_n)$出发
> > >    - 倒推：反向应用规则，直到所有分支都归结为基础事实(叶节点)为止
> > > 3. 语义：事实$R(A_1,A_n)$成立，当且仅当至少存在一颗$A_1$到$A_n$的推导树
> > >
> > > :two:不动点语义：从起点试图推导到结论
> > >
> > > 1. 要素：外延数据库$\text{EDB}$(基础事实)，内涵数据库$\text{IDB}$(导出事实)，立即后果算子$T_P$(每部的推导)
> > > 2. 推导：给定基础事实$\text{EDB}$，$\text{IDB}_{k+1}{=}\text{IDB}_k{\cup}T_P(\text{EDB}{\cup}\text{IDB}_k)$
> > >    - 开始：推导事实集初始为空，即$\text{IDB}_0{=}\varnothing$
> > >    - 一轮：输入所有已知的事实的可达点，即$\text{IDB}_1{=}T_P(\text{EDB})$
> > >    - 二轮：上轮结果$+$(上轮结果$\cup$基础点)的可达点，即$\text{IDB}_{2}{=}\text{IDB}_1{\cup}T_P(\text{EDB}{\cup}\text{IDB}_1)$
> > >    - 三轮：上轮结果$+$(上轮结果$\cup$基础点)的可达点，即$\text{IDB}_{3}{=}\text{IDB}_2{\cup}T_P(\text{EDB}{\cup}\text{IDB}_2)$
> > >    - $n$轮：一直迭代到$\text{IDB}_{k+1}{=}\text{IDB}_{k}$，输出最终收敛的$\text{IDB}_{k}$，即最小不动点
> > > 3. 语义：从基础事实出发，不断地利用规则推导，得到所有可能推导出的事实
>
> ## $\textbf{3.2. }\boldsymbol{K\textbf{-}}$关系上的$\textbf{Datalog}$
>
> > ### $\textbf{3.2.1. }\textbf{Datalog}$的证明论半环语义
> >
> > > :one:${\omega}\textbf{-}$连续半环是什么：具备完备性和连续性的半环
> > >
> > > 0. 前置分析：为何要${\omega}\textbf{-}$连续半环${\to}$能处理无穷推导，并能囊括包语义
> > >    - 无穷推导：当$\text{Datalog}$出现递归时，可能会产生无穷推导，进而结果的注释值等于无穷${\notin}K$
> > >    - 封闭半环：可以处理无限和，但加法必须是幂等的(如$a{\oplus}a{=}a$)，这与包语义的如$1{+}1{=}2$冲突
> > > 1. 前置概念：考虑半环$(K,{\oplus},{\otimes},0,1)$，以及$a_1,a_2,...{\in}K$
> > >    - 序的定义：对于$a_1,a_2{\in}K$，$a_1{\leq}a_2$等价于存在$x{\in}K$使$a_1{\oplus}x{=}a_2$
> > >    - ${\omega}\textbf{-}$链是啥：由序关系$\leq$链接的无限序列$\langle{}a_0,a_1,...\rangle{}$，即满足$a_0{\leq}a_1{\leq}...$的链
> > > 2. ${\omega}\textbf{-}$完备性：保证半环$(K,{\oplus},{\otimes},0,1)$上无限递归的过程，也有一个确定的(包括$\infty$)结果
> > >    - 完备：半环$K$是完备的，即任意${\omega}\textbf{-}$链$\langle{}a_0,a_1,...\rangle{}$都有一最小上界$a_{\text{sup}}{\in}K$，即$\displaystyle\lim_{i{\to}\infty}a_i{=}a_{\text{sup}}$
> > >    - 反例：包$(\mathbb{N},{+},{\times},0,1)$中自然数$\mathbb{N}$不具备完备性，如构造${\omega}\textbf{-}$链$\langle{}0,1,2,...\rangle{}$不可能存在上界 
> > >    - 转化：对于那些没有上界的的${\omega}\textbf{-}$链，强行让$\infty{\in}K$于是$\infty$就是其最小上界
> > > 3. ${\omega}\textbf{-}$连续性：可将$\otimes$分配到无限求和中$\displaystyle{}a{\otimes}\left(\sum_{i=0}^{\infty} b_i\right){=}\sum_{i=0}^{\infty}\left(a{\otimes}b_i\right)$，即分配律在处理无穷和时仍有效
> > > 4. 示例：几个主要的${\omega}\textbf{-}$连续半环
> > >    | 半环类型 | $\boldsymbol{(K,{\oplus},{\otimes},0,1)}$                  | 为何是$\boldsymbol{\omega}\textbf{-}$连续                    |
> > >    | :------: | :--------------------------------------------------------- | ------------------------------------------------------------ |
> > >    |   布尔   | $(B,{\lor},{\land},\text{false},\text{true})$              | $\text{false}{\leq}\text{true}$就是所有的${\omega}\textbf{-}$链，必有上界 |
> > >    |  布尔式  | $(\text{PosB}(B),{\lor},{\land},\text{false},\text{true})$ | 假定布尔变量$B$有限，$\text{PosB}(B)$也有限(有上界)          |
> > >    |    包    | $(\mathbb{N}^{\infty},{+},{\times},0,1)$                   | $\mathbb{N}$本身是不完备的，但是如上所说强行加入了$\infty$   |
> > >    |   热带   | $(\mathbb{N}^{\infty},{\min},{+},{\infty},0)$              | 同上，此外这个环描述的其实是最短路径优化                     |
> > >    |   幂集   | $(P(\Omega),{\cup},{\cap},{\varnothing},\Omega)$           | 若事件空间$\Omega$有限，其幂集$P(\Omega)$也有限(有上界)      |
> > >    |   模糊   | $([0,1],{\max},{\min},{0},1)$                              | $[0,1]$必定有最小上界$1$，该环可用来描述可能性               |
> > >
> > > :two:$\text{Datalog}$的证明论半环语义：$\displaystyle{}q(R)(t){=}\sum_{\tau\text { yields } t}\left(\prod_{t^{\prime}{\in}\text { leaves }(\tau)} R\left(t^{\prime}\right)\right)$ 
> > >
> > > 1. 含义：在${\omega}\textbf{-}$连续半环上，求一个输出元组$t$的注释值时，遵循以下步骤
> > >    - 第一步：先找出所有能推导出$t$的语法树，记录每个推导树的所有叶子节点的注释值
> > >    - 第二步：求每个推导树的叶节点注释值的积，再将所有语法树的积相加，极为$t$的注释值
> > > 2. 非递归：在环$(\mathbb{N}^{\infty},{+},{\times},0,1)$上，非递归规则$Q(x,y)\text{:-}R(x,z),R(z,y)$，即$Q{=}R{\bowtie}R$
> > >    $\begin{array}{|c|c|c|}\hline
> > >    \textbf{x}&\textbf{z}&\textbf{Anno.}\\\hline\hline
> > >    a&a&2\\\hline
> > >    a&b&3\\\hline
> > >    b&b&4\\\hline
> > >    \end{array}{\,\bowtie\,}\begin{array}{|c|c|c|}\hline
> > >    \textbf{z}&\textbf{y}&\textbf{Anno.}\\\hline\hline
> > >    a&a&2\\\hline
> > >    a&b&3\\\hline
> > >    b&b&4\\\hline
> > >    \end{array}{\,=\,}\begin{array}{|c|c|l|}\hline
> > >    \textbf{x}&\textbf{y}&\textbf{Anno.}\\\hline\hline
> > >    a&a&2{\times}2\\\hline
> > >    a&b&2{\times}3{+}3{\times}4\\\hline
> > >    b&b&4{\times}4\\\hline
> > >    \end{array}$
> > >    - 考虑$Q(a,b)\text{:-}R(a,a),R(a,b)$所代表的推导树，$R(a,a),R(a,b)$注释之积为$2{\times}3$
> > >    - 考虑$Q(a,b)\text{:-}R(a,b),R(b,b)$所代表的推导树，$R(a,b),R(b,b)$注释之积为$3{\times}4$
> > > 3. 递归：在环$(\mathbb{N}^{\infty},{+},{\times},0,1)$上，递归规则$\begin{cases}Q(x,y)\text{:-}R(x,y)\\Q(x,y)\text{:-}Q(x,z),Q(z,y)\end{cases}$，即$Q{=}R^n$(自$\text{Join}$无数次)
> > >    $\begin{array}{|c|c|c|}\hline
> > >    \textbf{x}&\textbf{z}&\textbf{Anno.}\\\hline\hline
> > >    a&a&2\\\hline
> > >    a&b&3\\\hline
> > >    b&b&4\\\hline
> > >    \end{array}{\,\bowtie\,}\begin{array}{|c|c|c|}\hline
> > >    \textbf{z}&\textbf{y}&\textbf{Anno.}\\\hline\hline
> > >    a&a&2\\\hline
> > >    a&b&3\\\hline
> > >    b&b&4\\\hline
> > >    \end{array}{\,\bowtie\,}...{\,=\,}\begin{array}{|c|c|c|}\hline
> > >    \textbf{x}&\textbf{y}&\textbf{Anno.}\\\hline\hline
> > >    a&a&{\infty}\\\hline
> > >    a&b&{\infty}\\\hline
> > >    b&b&{\infty}\\\hline
> > >    \end{array}$
> > >    - $Q(a,b)$利用规则$Q(x,y)\text{:-}Q(x,z),Q(z,y)$，得到推导树倒数第二层节点
> > >      ```txt
> > >      Q(a,b)                      | Q(a,b)
> > >      Q(a,a),Q(a,b)               | Q(a,b),Q(b,b)
> > >      Q(a,a),Q(a,a),Q(a,b)        | Q(a,b),Q(b,b),Q(b,b)
> > >      Q(a,a),Q(a,a),Q(a,a),Q(a,b) | Q(a,b),Q(b,b),Q(b,b),Q(b,b)
> > >      ........                    | ........
> > >      ```
> > >    - 再利用规则$Q(x,y)\text{:-}R(x,y)$，得到推导树的叶子节点
> > >      ```TXT
> > >      R(a,b)                      | R(a,b)
> > >      R(a,a),R(a,b)               | R(a,b),R(b,b)
> > >      R(a,a),R(a,a),R(a,b)        | R(a,b),R(b,b),R(b,b)
> > >      R(a,a),R(a,a),R(a,a),R(a,b) | R(a,b),R(b,b),R(b,b),R(b,b)
> > >      ........                    | ........
> > >      ```
> > >    - 合并每个推导树叶节点注释的累积，结果必定是$\infty$，然而这在${\omega}\textbf{-}$连续半环中是合法的结果
> > >
> > > :three:$\text{Datalog}$的证明论半环语义的性质
> > >
> > > 1. 合理性保证：对一个行数有限的数据库$R$，进行$\text{Datalog}$查询的结果$q(R)$的行数也有限
> > > 2. 非递归等价性：对于$K\text{-}$关系上的查询，以下两者得到的计算结果相同
> > >    - $\mathcal{RA}^+$视角：视查询为$\text{Join/Union}$等算子构成的算式，用关系代数半环语义计算注释值
> > >    - $\text{Datalog}$视角：将查询视作若干非递归的$\text{Datalog}$规则，用$\text{Datalog}$半环语义计算注释值
> > > 3. 语义一致性：以下两种方式查询结果一致
> > >    - 本文$\text{Datalog}$语义：用布尔半环注释数据库，用$\text{Datalog}$半环语义计算注释，保留为$\text{true}$者
> > >    - 传统$\text{Datalog}$语义：普通的$\text{Datalog}$的执行所得到的元组
> > >
> > > :four:$\text{Datalog}$的证明论半环语义的局限
> > >
> > > 1. 局限：虽然这种半环语义是良定义的，但执行层面不可能枚举无限种可能的推导树
> > > 2. 解决：引入完全等价的不动点语义，将$\text{Datalog}$规则翻译成代数方程，自底向上求解不动点
> >
> > ### $\textbf{3.2.2. }\textbf{Datalog}$的不动点论半环语义
> >
> > > :one:将$\text{Datalog}$的逻辑规则转化为方程组(代数系统)
> > >
> > > 1. 已知量$\&$未知数分配：已知量即基础事实$R$中所有的注释值，未知量即求解结果$Q$的所有注释值
> > > 2. 依据$\text{Datalog}$规则建立方程：在环$(\mathbb{N}^{\infty},{+},{\times},0,1)$上，考虑规则$\begin{cases}Q(x,y)\text{:-}R(x,y)\\Q(x,y)\text{:-}Q(x,z),Q(z,y)\end{cases}$ 
> > >    $R{\,=\,}\begin{array}{|c|c|c|}\hline
> > >    \hline
> > >    a&b&m\\\hline
> > >    a&c&n\\\hline
> > >    c&b&p\\\hline
> > >    b&d&r\\\hline
> > >    d&d&s\\\hline
> > >    \end{array}{\,和\,}Q{\,=\,}\begin{array}{|c|c|c|}\hline
> > >    \hline
> > >    a&b&\textbf{x}\\\hline
> > >    a&c&\textbf{y}\\\hline
> > >    c&b&\textbf{z}\\\hline
> > >    b&d&\textbf{u}\\\hline
> > >    d&d&\textbf{v}\\\hline
> > >    a&d&\textbf{w}\\\hline
> > >    \end{array}{\,\xRightarrow{}}\begin{cases} \mathbf{x}{=}m{+}\mathbf{y} \mathbf{z} \\ \mathbf{y}{=}n \\ \mathbf{z}{=}p \\ \mathbf{u}{=}r{+}\mathbf{u} \mathbf{v} \\ \mathbf{v}{=}s{+}\mathbf{v}^2 \\ \mathbf{w}{=}\mathbf{x} \mathbf{u}{+}\mathbf{w} \mathbf{v}\end{cases}$ 
> > >    - 考虑$Q(x,y)\text{:-}R(x,y)$：则$Q(a,b)$可由$R(a,b)$生成，于是$\mathbf{x}{=}m{+}{\cdots}$
> > >    - 考虑$Q(x,y)\text{:-}Q(x,z),Q(z,y)$：则$Q(a,b)$可由$Q(a,c)$和$Q(c,b)$生成，于是$\mathbf{x}{=}m{+}\mathbf{yz}$ 
> > >
> > > :two:方程的求解：不动点迭代法
> > >
> > > 1. 初始化：$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w}){=}(0,0,0,0,0,0)$
> > > 2. 第一轮：$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w}){=}(0,0,0,0,0,0)$带入右边${\to}$左边$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w}){=}(m,n,p,r,s,0)$
> > > 3. 第二轮：$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w}){=}(m,n,p,r,s,0)$带入右边${\to}$左边$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w}){=}(m{+}np,n,...)$
> > > 4. 第$n$轮：不断用方程组迭代，至$(\textbf{x},\textbf{y},\textbf{z},\textbf{u},\textbf{v},\textbf{w})$不变(即为不动点)，结果如下
> > >    $Q{\,=\,}\begin{array}{|c|c|l|}\hline
> > >    \hline
> > >    a&b&m{+}np\\\hline
> > >    a&c&n\\\hline
> > >    c&b&p\\\hline
> > >    b&d&r(1{+}v{+}v^2{+}{\cdots})\\\hline
> > >    d&d&s{+}s^2{+}2s^3{+}5s^4{+}{\cdots}\\\hline
> > >    a&d&r(m{+}np)(1{+}v{+}v^2{+}{\cdots})^2\\\hline
> > >    \end{array}{\,\xrightarrow[克林闭包]{v^*{=}1{+}v{+}v^2{+}{\cdots}}\,}Q{\,=\,}\begin{array}{|c|c|l|}\hline
> > >    \hline
> > >    a&b&m{+}np\\\hline
> > >    a&c&n\\\hline
> > >    c&b&p\\\hline
> > >    b&d&rv^*\\\hline
> > >    d&d&s{+}s^2{+}2s^3{+}5s^4{+}{\cdots}\\\hline
> > >    a&d&r(m{+}np)(v^*)^{2}\\\hline
> > >    \end{array}$
> > >
> > > :three:对不动点语义的分析
> > >
> > > 1. 语义等价性：由$\text{Datalog}$两种语义(证明论和不动点)得到的查询结果是完全等价的
> > > 2. 迭代的保证：在$\omega\text{-}$连续半环上，为何不动点迭代法是有效的
> > >    - 单调性：由于是正关系代数，方程中只有加乘，故每轮不动点迭代都递增(如$\textbf{x}_1{\leq}\textbf{x}_2{\leq}\textbf{x}_3...$)
> > >    - 完备性：保证了变量在不动点迭代过程中，即使不断递增但还是会有一个最小上界(最小不动点)
> > >    - 连续性：应用克林(克林闭包的克林)不动点定理的关键，即迭代停止处就是索要的最小不动点
> > > 3. 解的含义：以一个半环的视角，以$Q(a,b)$的注释$m{+}np$为例
> > >    - 包半环：$m/n/p$来自$a{\to}b/a{\to}c/c{\to}b$的路径数，$np$积则为$a{\to}c{\to}b$的路径数
> > >    - 溯源半环：$m$表示$Q(a,b)$一部分直接来自$R(a,b)$，$np$表示另一部分来自$R(a,c){\bowtie}R(c,b)$
> > > 4. 关于无穷大：良性与恶性的递归
> > >    |  递归  | 含义                                                         | 解结构                            |
> > >    | :----: | :----------------------------------------------------------- | :-------------------------------- |
> > >    |  线性  | 左边只以一次方出现在右边，如$\mathbf{u}{=}r{+}\mathbf{u} \mathbf{v}$ | 链式结构，解呈几何级数            |
> > >    | 非线性 | 左边以更高次方出现在右边，如$\mathbf{v}{=}s{+}\mathbf{v}^2$  | 组合结构 (如二叉树)，解呈复杂级数 |
> > >
> > > :four:$\text{Datalog}$上的因子分解定理
> > >
> > > 1. 内容：$q\left( {h\left( R\right) }\right){=}h\left( {q\left( R\right) }\right)$
> > >    - 要素：$R$为原始数据库(注释为溯源多项式)，$h$为同态函数(翻译多项式)，$q$为$\text{Datalog}$查询
> > >    - 含义：先翻译注释再查询即$q\left( {h\left( R\right) }\right)$，等价于先查询再翻译查询结果注释即$h\left( {q\left( R\right) }\right)$
> > > 2. 意义：一种通用性的宣言，即溯源半环上的$\text{Datalog}$查询是一种通用模型
>
> ## $\textbf{3.3. }$从溯源多项式$\textbf{→}$溯源正式幂级数
>
> > ### $\textbf{3.3.1. }$为何溯源多项式不够
> >
> > > :one:无限系数情形：考虑单位循环递归(一种特殊的线性递归)
> > >
> > > 1. 示例：考虑单位规则循环$\begin{cases}Q(x,y)\text{:-}R(x,y)\\R(x,y)\text{:-}Q(x,y)\end{cases}$，$Q(a,b)$推导树如下
> > >    ```txt
> > >    Q(a, b) <- R(a, b)
> > >    Q(a, b) <- R(a, b) <- Q(a, b) <- R(a, b)
> > >    Q(a, b) <- R(a, b) <- Q(a, b) <- R(a, b) <- Q(a, b) <- R(a, b)
> > >    ......
> > >    ```
> > > 2. 特点：有无穷多颗推导树，每颗推导树的叶节点的积都一样，也就是$\infty{\times}N$结构(系数为无穷)
> > > 3. 局限：对于多项式的一项，其系数并不能无限
> > >
> > > :two:无限项数情形：线性或非线性递归
> > >
> > > 1. 示例：之前讨论的例子中解得的$\textbf{v}{=}s{+}s^2{+}2s^3{+}5s^4{+}{\cdots}$及$\textbf{u}{=}r(1{+}v{+}v^2{+}{\cdots})$
> > > 2. 局限：多项式并不允许表示无限多个项，除非用级数
> >
> > ### $\textbf{3.3.2. }$形式幂级数半环
> >
> > > :one:$\text{Datalog}$溯源半环
> > >
> > > 1. 是啥：将溯源多项式半环$(\mathbb{N}[X],+,\times,0,1)$的$\mathbb{N}[X]$换成${\mathbb{N}^{\infty}[[X]]}$ 
> > >    |         结构          | 含义                                                         |
> > >    | :-------------------: | ------------------------------------------------------------ |
> > >    |          $X$          | 数据库中每个元组的$\text{ID}$，在溯源数据库中就是元组的注释，记录参与贡献的元组 |
> > >    |       $[[\,]]$        | 表示可以放入无穷多的项，区别于多项式的$[\,\,]$只能放入有限多的项 |
> > >    | $\mathbb{N}^{\infty}$ | 对自然数的扩展，认为无穷也是一种自然数，一起可以作为每一项的系数 |
> > > 2. 性质：任然是一个${\omega}\textbf{-}$连续半环，故不动点求解任然适用
> > >
> > > :two:${\mathbb{N}^{\infty}[[X]]}$的理论保证
> > >
> > > 1. 向下兼容：形式幂级数囊括了多项式，在$\mathbb{N}[X]$上执行与按同样方式在${\mathbb{N}^{\infty}[[X]]}$上执行结果一样
> > > 2. 因子分解：和溯源多项式半环上的$\text{Datalog}$因子分解一样，$q\left( {h\left( R\right) }\right){=}h\left( {q\left( R\right) }\right)$
> > >    - 要素：$R$为原始数据库(注释为溯源形式幂级数)，$h$为同态函数(翻译幂级数)，$q$为$\text{Datalog}$查询
> > >    - 保证：一定存在至少一个$h$，可将溯源形式幂级数，翻译成其它注释值(如布尔$/$数目等)
> > >    - 含义：先翻译注释再查询即$q\left( {h\left( R\right) }\right)$，等价于先查询再翻译查询结果注释即$h\left( {q\left( R\right) }\right)$
> > > 3. 可分析性：只有一种情况溯源形式幂级数才会出现无穷系数，即单位规则循环
> > >
> > >    - 所谓单位：`Body`只有一个`atom`，例如`P:-Q`
> > >
> > >    - 所谓循环：即所有规则最后会成为一个环，如下三个例子
> > >
> > >      ```txt
> > >      R1 :- R2  |  R1 :- R2  |  R1 :- R2
> > >      R2 :- R1  |  R2 :- R3  |  R2 :- R3
> > >                   R3 :- R1  |  R3 :- R2
> > >                             |  R2 :- R1
> > >      ```

# $\textbf{4. }$溯源级数计算与应用

> ## $\textbf{4.1. }$溯源级数计算
>
> > :one:$\text{All-Trees}$算法：通过让推导树自底向上构建实现的不动点计算，并判断溯源是否无限
> >
> > 1. 初始：构建两个数据结构
> >    |        结构        | 作用                               | 初始化输入什么                 |
> >    | :----------------: | ---------------------------------- | ------------------------------ |
> >    |     白名单$T$      | 存放当前已知的有限推导树           | 所有已知元组(只有一节的推导树) |
> >    | 黑名单$T^{\infty}$ | 存放已经确定的拥有无限推导树的元组 | 空                             |
> > 2. 迭代：自底向上的搭建
> >    |        输入对象        |           操作           | 如果某元组匹配成功....                           |
> >    | :--------------------: | :----------------------: | ------------------------------------------------ |
> >    |    $T$中所有树的根     | 匹配$\text{Datalog}$规则 | 原有推导树的根找到其父节点，再向上生长一层       |
> >    | $T^{\infty}$中所有元组 | 匹配$\text{Datalog}$规则 | 原有元组就能无限推导，其父节点也必定可以无限推导 |
> >    - 二者迭代的结果，共同构成待筛选的推导树集(即使由$T^{\infty}$迭代出来的仅两层的推导树必被简剪枝)
> > 3. 审查：对所有待筛选的推导树，自顶向下的检查
> >    |   检查对象   | 什么情况下推导树不能过审                     | 解释                         |
> >    | :----------: | -------------------------------------------- | ---------------------------- |
> >    | 根直接子节点 | 某树至少有一个根的直接子节点在$T^{\infty}$中 | 子节点可无穷推导，父节点也可 |
> >    |  每一层节点  | 在任意深度发现了与根节点一致的元组           | 构成循环，自身不断导出自身   |
> >    - 更新：将过审的推导树加入$T$，不能过审的推导树的根节点加入到$T^{\infty}$中
> > 4. 停止：当$T/T^{\infty}$的成员都不变化时
> >    - 输出：计算出元组的溯源多项式
> >      |         条件         | 元组的溯源结果(多项式)                                       |
> >      | :------------------: | :----------------------------------------------------------- |
> >      | 元组在$T^{\infty}$中 | $\infty$                                                     |
> >      |  元组为$T$中树的根   | 找到所有以该元组为根的推导树，计算每棵树叶子累乘，再将累乘累加 |
> >    - 补充：对于在$T^{\infty}$中的元组，检测其溯源结果的无穷是哪一种
> >      |  无穷类型  | 环路的种类                                                   |
> >      | :--------: | :----------------------------------------------------------- |
> >      | 无穷多的项 | 元组对应推导树必定有环路，而且环路包含非单位规则(如`a:-b,c`及`c:-a`) |
> >      | 无穷的系数 | 元组对应推导树必定有环路，而且环路全为单位规则(如`a:b`及`b:-a`) |
> >
> > :two:$\text{M-C}$算法：深入某无限推导的元组$t$，弄清其特定的单项式$\mu$对注释值贡献了多少次(系数)
> >
> > 1. 前置：用元组$\text{-}$单项式对$(t,\mu)$描述一类推导树
> >    - 结构：$\mu$是一个单项式，为推导树的叶节点的累乘，这些叶节点最终可导出$t$
> >    - 种类：按照$\mu$所代表的叶节点组合，有多少种方法可以推导出元组$t$
> >      |      类型       | 特点                                       | 备注                                 |
> >      | :-------------: | ------------------------------------------ | :----------------------------------- |
> >      |  普通$(t,\mu)$  | $\mu$的叶节点组合，仅有有限种方法导出$t$   | $t$的注释中，$\mu$项系数有限         |
> >      | 无穷$(t',\mu')$ | $\mu’$的叶节点组合，可有无限种方法导出$t'$ | $t'$的注释中，$\mu’$项系数为$\infty$ |
> >    - 补充：上章讨论过，只有出现单位规则循环时，幂级数才会有无穷系数，即才会有无穷$(t',\mu')$
> > 2. 初始：对某可无穷推导元组的溯源幂级数，输入其中目标单项式$\mu$，构建两个数据结构
> >    |        结构        | 存放内容                                            | 初始化输入什么                             |
> >    | :----------------: | --------------------------------------------------- | ------------------------------------------ |
> >    |     白名单$T$      | 自底向上生长，有潜力得到$\mu$的推导树的集合         | $\mu$的组成，如$\mu{=}rs^2$则$T{=}\{r,s\}$ |
> >    | 黑名单$P^{\infty}$ | 目前已经发现的无穷元组$\text{-}$单项式对$(t',\mu')$ | 空                                         |
> > 3. 迭代：与$\text{All-Trees}$类似
> >    - 生成：让$T$中所有推导树根节点匹配$\text{Datalog}$规则向上生长，可能引入不存在于$\mu$中的叶节点
> >      |      情形      | 匹配的规则时....                              |
> >      | :------------: | :-------------------------------------------- |
> >      | 不引入新叶节点 | 规则的所有`atom`仅需$T$中推导树的根节点       |
> >      | 需引入新叶节点 | 规则有的`atom`需要$T$中推导树的根节点外的结点 |
> >    - 剪枝：处理引入的不存在于$\mu$中的叶节点，以及过度引入的$\mu$中的叶节点
> >      |   情形   | 剪枝条件                              | 示例                                    |
> >      | :------: | :------------------------------------ | --------------------------------------- |
> >      | 无中生有 | 推导树叶节点中有$\mu$不包含的元素     | 当$\mu{=}rs^2$时，推导树叶节点含$p$     |
> >      | 种类越界 | 推导树叶节点中某元素数量超过$\mu$中的 | 当$\mu{=}rs^2$时，推导树叶节点含三个$s$ |
> > 4. 检测：哪些元组的注释具有无穷系数
> >    | 检测方式 | 对于某推导树$\boldsymbol{(t_0,\mu_0)}$     | 对$\boldsymbol{P^{\infty}}$操作 |      |
> >    | :------: | ------------------------------------------ | :-----------------------------: | ---- |
> >    | 继承检测 | 若其有某颗子树为$(t',\mu'){\in}P^{\infty}$ |       将$(t_0,\mu_0)$塞入       |      |
> >    | 环路检测 | 若其从根结点$t_0$往下也有$t_0$(成环)       |       将$(t_0,\mu_0)$塞入       |      |
> > 5. 终止：由于搜索空间被$\mu$严格限制算法必有限步终止，输出系数$C$($t$的注释中项$\mu$的系数)
> >    |              情形              | 返回$\boldsymbol{C}$的值                  |
> >    | :----------------------------: | ----------------------------------------- |
> >    | 目标$(t, \mu)$不在$P^\infty$中 | $C{=}T$中所有符合$(t, \mu)$的推导树的总数 |
> >    |  目标$(t, \mu)$在$P^\infty$中  | $C{=}{\infty}$                            |
>
> ## $\textbf{4.2. }$要点的补充(从这开始放水了，都是些啥啊)
>
> > ### $\textbf{4.2.1. }$对$\textbf{All-Tree}$的再思考
> >
> > > :one:$\text{All-Trees}$算法对几种具体语义的处理
> > >
> > > 1. 对包语义：天然可处理包语义，因为包的注释是自然数，对自然数进行无穷运算后得到的就是无穷
> > > 2. 对其它语义：存在一定偏差，本质上源于幂等性
> > >    - 对于布尔半环：由于布尔值$x{\lor}x{=}x$，所以对布尔值的无穷运算还是布尔值，并不能用无穷表示
> > >    - 对于幂集半环：由于事件$A{\cup}A{=}A$，所以对事件的无穷运算还是事件，并不能用无穷表示
> > >
> > > :two:$\text{All-Trees}$算法的修改：使之能处理具有幂等性的语义
> > >
> > > 1. 核心修改：重新定义新的推导树，考虑一类推导树$(t,\mu)$
> > >    - 修改前：根$t$相同且叶累积$\mu$相同但内部结构(推导路径)不同，则视作新的推导树
> > >    - 修改后：根$t$相同且叶累积$\mu$相同则视作一类；仅$\mu$更小(如$xy$小于$xyz$)才视作新(更好)的推导树
> > > 2. 为何有效：吸收律$a{+}a{\times}b{=}a$的体现
> > >    - 去除冗余：选择尽可能小的$\mu$以去除冗余信息，比如$xy$就能导出$t$，那还要$xyz$的推导树干啥
> >
> > ### $\textbf{4.2.2. }$查询包含
> >
> > > :one:分配格是什么
> > >
> > > 1. 格：即$(L,{\oplus},{\otimes})$的代数系统，满足交换律$/$结合律，以及吸收率$\begin{cases}a{\oplus}(a{\otimes}b){=}a\\a{\otimes}(a{\oplus}b){=}a\end{cases}$
> > > 2. 分配格：在格的基础上，还满足分配律$\begin{cases}a{\oplus}(b{\otimes}c){=}(a{\oplus}b){\otimes}(a{\oplus}c)\\a{\otimes}(b{\oplus}c){=}(a{\otimes}b){\oplus}(a{\otimes}c)\end{cases}$
> > >
> > > :two:关于查询包含
> > >
> > > 1. 定义：$K\text{-}$半环语义下查询$q_1$被$q_2$包含(记作$q_1{\sqsubseteq_K}q_2$)${\Leftrightarrow}$数据库$R$中任意元组$t$有$q_1(R)(t){\leq}q_2(R)(t)$
> > > 2. 示例：布尔半环中$\text{false}{\leq}\text{true}$，包中$\leq$就表示自然数的小于等于
> > > 3. 性质：若$K\text{-}$半环是一个分配格，查询是合区查询并集(多个$\text{CQ}$取$\text{or}$)，则$q_1{\sqsubseteq_K}q_2$和$q_1{\sqsubseteq_{\mathbb{B}}}q_2$等价

